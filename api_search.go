/*
Bitbucket API

Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.

API version: 2.0
Contact: support@bitbucket.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SearchApiService SearchApi service
type SearchApiService service

type SearchApiSearchAccountRequest struct {
	ctx context.Context
	ApiService *SearchApiService
	selectedUser string
	searchQuery *string
	page *int32
	pagelen *int32
}

// The search query
func (r SearchApiSearchAccountRequest) SearchQuery(searchQuery string) SearchApiSearchAccountRequest {
	r.searchQuery = &searchQuery
	return r
}

// Which page of the search results to retrieve
func (r SearchApiSearchAccountRequest) Page(page int32) SearchApiSearchAccountRequest {
	r.page = &page
	return r
}

// How many search results to retrieve per page
func (r SearchApiSearchAccountRequest) Pagelen(pagelen int32) SearchApiSearchAccountRequest {
	r.pagelen = &pagelen
	return r
}

func (r SearchApiSearchAccountRequest) Execute() (*SearchResultPage, *http.Response, error) {
	return r.ApiService.SearchAccountExecute(r)
}

/*
SearchAccount Search for code in a user's repositories

Search for code in the repositories of the specified user.

Searching across all repositories:

```
curl 'https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/search/code?search_query=foo'
{
  "size": 1,
  "page": 1,
  "pagelen": 10,
  "query_substituted": false,
  "values": [
    {
      "type": "code_search_result",
      "content_match_count": 2,
      "content_matches": [
        {
          "lines": [
            {
              "line": 2,
              "segments": []
            },
            {
              "line": 3,
              "segments": [
                {
                  "text": "def "
                },
                {
                  "text": "foo",
                  "match": true
                },
                {
                  "text": "():"
                }
              ]
            },
            {
              "line": 4,
              "segments": [
                {
                  "text": "    print(\"snek\")"
                }
              ]
            },
            {
              "line": 5,
              "segments": []
            }
          ]
        }
      ],
      "path_matches": [
        {
          "text": "src/"
        },
        {
          "text": "foo",
          "match": true
        },
        {
          "text": ".py"
        }
      ],
      "file": {
        "path": "src/foo.py",
        "type": "commit_file",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/src/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b/src/foo.py"
          }
        }
      }
    }
  ]
}
```

Note that searches can match in the file's text (`content_matches`),
the path (`path_matches`), or both as in the example above.

You can use the same syntax for the search query as in the UI, e.g.
to only search within a specific repository:

```
curl 'https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/search/code?search_query=foo+repo:demo'
# results from the "demo" repository
```

Similar to other APIs, you can request more fields using a
`fields` query parameter. E.g. to get some more information about
the repository of matched files (the `%2B` is a URL-encoded `+`):

```
curl 'https://api.bitbucket.org/2.0/users/{ed08f5e1-605b-4f4a-aee4-6c97628a673e}/search/code'\
     '?search_query=foo&fields=%2Bvalues.file.commit.repository'
{
  "size": 1,
  "page": 1,
  "pagelen": 10,
  "query_substituted": false,
  "values": [
    {
      "type": "code_search_result",
      "content_match_count": 1,
      "content_matches": [...],
      "path_matches": [...],
      "file": {
        "commit": {
          "type": "commit",
          "hash": "ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b",
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/commit/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b"
            },
            "html": {
              "href": "https://bitbucket.org/my-workspace/demo/commits/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b"
            }
          },
          "repository": {
            "name": "demo",
            "type": "repository",
            "full_name": "my-workspace/demo",
            "links": {
              "self": {
                "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo"
              },
              "html": {
                "href": "https://bitbucket.org/my-workspace/demo"
              },
              "avatar": {
                "href": "https://bytebucket.org/ravatar/%7B850e1749-781a-4115-9316-df39d0600e7a%7D?ts=default"
              }
            },
            "uuid": "{850e1749-781a-4115-9316-df39d0600e7a}"
          }
        },
        "type": "commit_file",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/src/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b/src/foo.py"
          }
        },
        "path": "src/foo.py"
      }
    }
  ]
}
```

Try `fields=%2Bvalues.*.*.*.*` to get an idea what's possible.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 @return SearchApiSearchAccountRequest
*/
func (a *SearchApiService) SearchAccount(ctx context.Context, selectedUser string) SearchApiSearchAccountRequest {
	return SearchApiSearchAccountRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
	}
}

// Execute executes the request
//  @return SearchResultPage
func (a *SearchApiService) SearchAccountExecute(r SearchApiSearchAccountRequest) (*SearchResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchApiService.SearchAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/search/code"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", url.PathEscape(parameterToString(r.selectedUser, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchQuery == nil {
		return localVarReturnValue, nil, reportError("searchQuery is required and must be specified")
	}

	localVarQueryParams.Add("search_query", parameterToString(*r.searchQuery, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pagelen != nil {
		localVarQueryParams.Add("pagelen", parameterToString(*r.pagelen, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchApiSearchTeamRequest struct {
	ctx context.Context
	ApiService *SearchApiService
	username string
	searchQuery *string
	page *int32
	pagelen *int32
}

// The search query
func (r SearchApiSearchTeamRequest) SearchQuery(searchQuery string) SearchApiSearchTeamRequest {
	r.searchQuery = &searchQuery
	return r
}

// Which page of the search results to retrieve
func (r SearchApiSearchTeamRequest) Page(page int32) SearchApiSearchTeamRequest {
	r.page = &page
	return r
}

// How many search results to retrieve per page
func (r SearchApiSearchTeamRequest) Pagelen(pagelen int32) SearchApiSearchTeamRequest {
	r.pagelen = &pagelen
	return r
}

func (r SearchApiSearchTeamRequest) Execute() (*SearchResultPage, *http.Response, error) {
	return r.ApiService.SearchTeamExecute(r)
}

/*
SearchTeam Search for code in a team's repositories

Search for code in the repositories of the specified team.

Searching across all repositories:

```
curl 'https://api.bitbucket.org/2.0/teams/team_name/search/code?search_query=foo'
{
  "size": 1,
  "page": 1,
  "pagelen": 10,
  "query_substituted": false,
  "values": [
    {
      "type": "code_search_result",
      "content_match_count": 2,
      "content_matches": [
        {
          "lines": [
            {
              "line": 2,
              "segments": []
            },
            {
              "line": 3,
              "segments": [
                {
                  "text": "def "
                },
                {
                  "text": "foo",
                  "match": true
                },
                {
                  "text": "():"
                }
              ]
            },
            {
              "line": 4,
              "segments": [
                {
                  "text": "    print(\"snek\")"
                }
              ]
            },
            {
              "line": 5,
              "segments": []
            }
          ]
        }
      ],
      "path_matches": [
        {
          "text": "src/"
        },
        {
          "text": "foo",
          "match": true
        },
        {
          "text": ".py"
        }
      ],
      "file": {
        "path": "src/foo.py",
        "type": "commit_file",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/src/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b/src/foo.py"
          }
        }
      }
    }
  ]
}
```

Note that searches can match in the file's text (`content_matches`),
the path (`path_matches`), or both as in the example above.

You can use the same syntax for the search query as in the UI, e.g.
to only search within a specific repository:

```
curl 'https://api.bitbucket.org/2.0/teams/team_name/search/code?search_query=foo+repo:demo'
# results from the "demo" repository
```

Similar to other APIs, you can request more fields using a
`fields` query parameter. E.g. to get some more information about
the repository of matched files (the `%2B` is a URL-encoded `+`):

```
curl 'https://api.bitbucket.org/2.0/teams/team_name/search/code'\
     '?search_query=foo&fields=%2Bvalues.file.commit.repository'
{
  "size": 1,
  "page": 1,
  "pagelen": 10,
  "query_substituted": false,
  "values": [
    {
      "type": "code_search_result",
      "content_match_count": 1,
      "content_matches": [...],
      "path_matches": [...],
      "file": {
        "commit": {
          "type": "commit",
          "hash": "ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b",
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/commit/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b"
            },
            "html": {
              "href": "https://bitbucket.org/my-workspace/demo/commits/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b"
            }
          },
          "repository": {
            "name": "demo",
            "type": "repository",
            "full_name": "my-workspace/demo",
            "links": {
              "self": {
                "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo"
              },
              "html": {
                "href": "https://bitbucket.org/my-workspace/demo"
              },
              "avatar": {
                "href": "https://bytebucket.org/ravatar/%7B850e1749-781a-4115-9316-df39d0600e7a%7D?ts=default"
              }
            },
            "uuid": "{850e1749-781a-4115-9316-df39d0600e7a}"
          }
        },
        "type": "commit_file",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/src/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b/src/foo.py"
          }
        },
        "path": "src/foo.py"
      }
    }
  ]
}
```

Try `fields=%2Bvalues.*.*.*.*` to get an idea what's possible.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The account to search in; either the username or the UUID in curly braces
 @return SearchApiSearchTeamRequest
*/
func (a *SearchApiService) SearchTeam(ctx context.Context, username string) SearchApiSearchTeamRequest {
	return SearchApiSearchTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return SearchResultPage
func (a *SearchApiService) SearchTeamExecute(r SearchApiSearchTeamRequest) (*SearchResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchApiService.SearchTeam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/search/code"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchQuery == nil {
		return localVarReturnValue, nil, reportError("searchQuery is required and must be specified")
	}

	localVarQueryParams.Add("search_query", parameterToString(*r.searchQuery, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pagelen != nil {
		localVarQueryParams.Add("pagelen", parameterToString(*r.pagelen, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SearchApiSearchWorkspaceRequest struct {
	ctx context.Context
	ApiService *SearchApiService
	workspace string
	searchQuery *string
	page *int32
	pagelen *int32
}

// The search query
func (r SearchApiSearchWorkspaceRequest) SearchQuery(searchQuery string) SearchApiSearchWorkspaceRequest {
	r.searchQuery = &searchQuery
	return r
}

// Which page of the search results to retrieve
func (r SearchApiSearchWorkspaceRequest) Page(page int32) SearchApiSearchWorkspaceRequest {
	r.page = &page
	return r
}

// How many search results to retrieve per page
func (r SearchApiSearchWorkspaceRequest) Pagelen(pagelen int32) SearchApiSearchWorkspaceRequest {
	r.pagelen = &pagelen
	return r
}

func (r SearchApiSearchWorkspaceRequest) Execute() (*SearchResultPage, *http.Response, error) {
	return r.ApiService.SearchWorkspaceExecute(r)
}

/*
SearchWorkspace Search for code in a workspace

Search for code in the repositories of the specified workspace.

Searching across all repositories:

```
curl 'https://api.bitbucket.org/2.0/workspaces/workspace_slug_or_uuid/search/code?search_query=foo'
{
  "size": 1,
  "page": 1,
  "pagelen": 10,
  "query_substituted": false,
  "values": [
    {
      "type": "code_search_result",
      "content_match_count": 2,
      "content_matches": [
        {
          "lines": [
            {
              "line": 2,
              "segments": []
            },
            {
              "line": 3,
              "segments": [
                {
                  "text": "def "
                },
                {
                  "text": "foo",
                  "match": true
                },
                {
                  "text": "():"
                }
              ]
            },
            {
              "line": 4,
              "segments": [
                {
                  "text": "    print(\"snek\")"
                }
              ]
            },
            {
              "line": 5,
              "segments": []
            }
          ]
        }
      ],
      "path_matches": [
        {
          "text": "src/"
        },
        {
          "text": "foo",
          "match": true
        },
        {
          "text": ".py"
        }
      ],
      "file": {
        "path": "src/foo.py",
        "type": "commit_file",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/src/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b/src/foo.py"
          }
        }
      }
    }
  ]
}
```

Note that searches can match in the file's text (`content_matches`),
the path (`path_matches`), or both as in the example above.

You can use the same syntax for the search query as in the UI, e.g.
to only search within a specific repository:

```
curl 'https://api.bitbucket.org/2.0/workspaces/my-workspace/search/code?search_query=foo+repo:demo'
# results from the "demo" repository
```

Similar to other APIs, you can request more fields using a
`fields` query parameter. E.g. to get some more information about
the repository of matched files (the `%2B` is a URL-encoded `+`):

```
curl 'https://api.bitbucket.org/2.0/workspaces/my-workspace/search/code'\
     '?search_query=foo&fields=%2Bvalues.file.commit.repository'
{
  "size": 1,
  "page": 1,
  "pagelen": 10,
  "query_substituted": false,
  "values": [
    {
      "type": "code_search_result",
      "content_match_count": 1,
      "content_matches": [...],
      "path_matches": [...],
      "file": {
        "commit": {
          "type": "commit",
          "hash": "ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b",
          "links": {
            "self": {
              "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/commit/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b"
            },
            "html": {
              "href": "https://bitbucket.org/my-workspace/demo/commits/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b"
            }
          },
          "repository": {
            "name": "demo",
            "type": "repository",
            "full_name": "my-workspace/demo",
            "links": {
              "self": {
                "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo"
              },
              "html": {
                "href": "https://bitbucket.org/my-workspace/demo"
              },
              "avatar": {
                "href": "https://bytebucket.org/ravatar/%7B850e1749-781a-4115-9316-df39d0600e7a%7D?ts=default"
              }
            },
            "uuid": "{850e1749-781a-4115-9316-df39d0600e7a}"
          }
        },
        "type": "commit_file",
        "links": {
          "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/my-workspace/demo/src/ad6964b5fe2880dbd9ddcad1c89000f1dbcbc24b/src/foo.py"
          }
        },
        "path": "src/foo.py"
      }
    }
  ]
}
```

Try `fields=%2Bvalues.*.*.*.*` to get an idea what's possible.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace The workspace to search in; either the slug or the UUID in curly braces
 @return SearchApiSearchWorkspaceRequest
*/
func (a *SearchApiService) SearchWorkspace(ctx context.Context, workspace string) SearchApiSearchWorkspaceRequest {
	return SearchApiSearchWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

// Execute executes the request
//  @return SearchResultPage
func (a *SearchApiService) SearchWorkspaceExecute(r SearchApiSearchWorkspaceRequest) (*SearchResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchApiService.SearchWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/search/code"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchQuery == nil {
		return localVarReturnValue, nil, reportError("searchQuery is required and must be specified")
	}

	localVarQueryParams.Add("search_query", parameterToString(*r.searchQuery, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pagelen != nil {
		localVarQueryParams.Add("pagelen", parameterToString(*r.pagelen, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
