/*
Bitbucket API

Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.

API version: 2.0
Contact: support@bitbucket.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bitbucket

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PipelinesApiService PipelinesApi service
type PipelinesApiService service

type PipelinesApiCreateDeploymentVariableRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	environmentUuid string
	body *DeploymentVariable
}

// The variable to create
func (r PipelinesApiCreateDeploymentVariableRequest) Body(body DeploymentVariable) PipelinesApiCreateDeploymentVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreateDeploymentVariableRequest) Execute() (*DeploymentVariable, *http.Response, error) {
	return r.ApiService.CreateDeploymentVariableExecute(r)
}

/*
CreateDeploymentVariable Create a variable for an environment

Create a deployment environment level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param environmentUuid The environment.
 @return PipelinesApiCreateDeploymentVariableRequest
*/
func (a *PipelinesApiService) CreateDeploymentVariable(ctx context.Context, workspace string, repoSlug string, environmentUuid string) PipelinesApiCreateDeploymentVariableRequest {
	return PipelinesApiCreateDeploymentVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
	}
}

// Execute executes the request
//  @return DeploymentVariable
func (a *PipelinesApiService) CreateDeploymentVariableExecute(r PipelinesApiCreateDeploymentVariableRequest) (*DeploymentVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateDeploymentVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", url.PathEscape(parameterToString(r.environmentUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiCreatePipelineForRepositoryRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	body *Pipeline
}

// The pipeline to initiate.
func (r PipelinesApiCreatePipelineForRepositoryRequest) Body(body Pipeline) PipelinesApiCreatePipelineForRepositoryRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreatePipelineForRepositoryRequest) Execute() (*Pipeline, *http.Response, error) {
	return r.ApiService.CreatePipelineForRepositoryExecute(r)
}

/*
CreatePipelineForRepository Run a pipeline

Endpoint to create and initiate a pipeline.
There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.
# Trigger a Pipeline for a branch
One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.
The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
  -d '
  {
    "target": {
      "ref_type": "branch",
      "type": "pipeline_ref_target",
      "ref_name": "master"
    }
  }'
```
# Trigger a Pipeline for a commit on a branch or tag
You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).
The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.

The following reference types are supported:

* `branch`
* `named_branch`
* `bookmark`
 * `tag`

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
  https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
  -d '
  {
    "target": {
      "commit": {
        "type": "commit",
        "hash": "ce5b7431602f7cbba007062eeb55225c6e18e956"
      },
      "ref_type": "branch",
      "type": "pipeline_ref_target",
      "ref_name": "master"
    }
  }'
```
# Trigger a specific pipeline definition for a commit
You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit.
In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
 -d '
  {
     "target": {
      "commit": {
         "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
         "type":"commit"
       },
        "selector": {
           "type":"custom",
              "pattern":"Deploy to production"
          },
        "type":"pipeline_commit_target"
   }
  }'
```
# Trigger a specific pipeline definition for a commit on a branch or tag
You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference.
In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
 -d '
  {
     "target": {
      "commit": {
         "hash":"a3c4e02c9a3755eccdc3764e6ea13facdf30f923",
         "type":"commit"
       },
       "selector": {
          "type": "custom",
          "pattern": "Deploy to production"
       },
       "type": "pipeline_ref_target",
       "ref_name": "master",
       "ref_type": "branch"
     }
  }'
```


# Trigger a custom pipeline with variables
In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
 -d '
  {
    "target": {
      "type": "pipeline_ref_target",
      "ref_type": "branch",
      "ref_name": "master",
      "selector": {
        "type": "custom",
        "pattern": "Deploy to production"
      }
    },
    "variables": [
      {
        "key": "var1key",
        "value": "var1value",
        "secured": true
      },
      {
        "key": "var2key",
        "value": "var2value"
      }
    ]
  }'
```

# Trigger a pull request pipeline

You can also initiate a pipeline for a specific pull request.

### Example

```
$ curl -X POST -is -u username:password \
  -H 'Content-Type: application/json' \
 https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
 -d '
  {
	"target": {
      "type": "pipeline_pullrequest_target",
	  "source": "pull-request-branch",
      "destination": "master",
      "destination_commit": {
      	 "hash" : "9f848b7"
      },
      "commit": {
      	"hash" : "1a372fc"
      },
      "pullrequest" : {
      	"id" : "3"
      },
	  "selector": {
        "type": "pull-requests",
        "pattern": "**"
      }
    }
  }'
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiCreatePipelineForRepositoryRequest
*/
func (a *PipelinesApiService) CreatePipelineForRepository(ctx context.Context, workspace string, repoSlug string) PipelinesApiCreatePipelineForRepositoryRequest {
	return PipelinesApiCreatePipelineForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return Pipeline
func (a *PipelinesApiService) CreatePipelineForRepositoryExecute(r PipelinesApiCreatePipelineForRepositoryRequest) (*Pipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiCreatePipelineVariableForTeamRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	username string
	body *PipelineVariable
}

// The variable to create.
func (r PipelinesApiCreatePipelineVariableForTeamRequest) Body(body PipelineVariable) PipelinesApiCreatePipelineVariableForTeamRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreatePipelineVariableForTeamRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.CreatePipelineVariableForTeamExecute(r)
}

/*
CreatePipelineVariableForTeam Create a variable for a user

Create an account level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The account.
 @return PipelinesApiCreatePipelineVariableForTeamRequest

Deprecated
*/
func (a *PipelinesApiService) CreatePipelineVariableForTeam(ctx context.Context, username string) PipelinesApiCreatePipelineVariableForTeamRequest {
	return PipelinesApiCreatePipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return PipelineVariable
// Deprecated
func (a *PipelinesApiService) CreatePipelineVariableForTeamExecute(r PipelinesApiCreatePipelineVariableForTeamRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineVariableForTeam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiCreatePipelineVariableForUserRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	selectedUser string
	body *PipelineVariable
}

// The variable to create.
func (r PipelinesApiCreatePipelineVariableForUserRequest) Body(body PipelineVariable) PipelinesApiCreatePipelineVariableForUserRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreatePipelineVariableForUserRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.CreatePipelineVariableForUserExecute(r)
}

/*
CreatePipelineVariableForUser Create a variable for a user

Create a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 @return PipelinesApiCreatePipelineVariableForUserRequest

Deprecated
*/
func (a *PipelinesApiService) CreatePipelineVariableForUser(ctx context.Context, selectedUser string) PipelinesApiCreatePipelineVariableForUserRequest {
	return PipelinesApiCreatePipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
	}
}

// Execute executes the request
//  @return PipelineVariable
// Deprecated
func (a *PipelinesApiService) CreatePipelineVariableForUserExecute(r PipelinesApiCreatePipelineVariableForUserRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineVariableForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", url.PathEscape(parameterToString(r.selectedUser, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiCreatePipelineVariableForWorkspaceRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	body *PipelineVariable
}

// The variable to create.
func (r PipelinesApiCreatePipelineVariableForWorkspaceRequest) Body(body PipelineVariable) PipelinesApiCreatePipelineVariableForWorkspaceRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreatePipelineVariableForWorkspaceRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.CreatePipelineVariableForWorkspaceExecute(r)
}

/*
CreatePipelineVariableForWorkspace Create a variable for a workspace

Create a workspace level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @return PipelinesApiCreatePipelineVariableForWorkspaceRequest
*/
func (a *PipelinesApiService) CreatePipelineVariableForWorkspace(ctx context.Context, workspace string) PipelinesApiCreatePipelineVariableForWorkspaceRequest {
	return PipelinesApiCreatePipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

// Execute executes the request
//  @return PipelineVariable
func (a *PipelinesApiService) CreatePipelineVariableForWorkspaceExecute(r PipelinesApiCreatePipelineVariableForWorkspaceRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreatePipelineVariableForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiCreateRepositoryPipelineKnownHostRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	body *PipelineKnownHost
}

// The known host to create.
func (r PipelinesApiCreateRepositoryPipelineKnownHostRequest) Body(body PipelineKnownHost) PipelinesApiCreateRepositoryPipelineKnownHostRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreateRepositoryPipelineKnownHostRequest) Execute() (*PipelineKnownHost, *http.Response, error) {
	return r.ApiService.CreateRepositoryPipelineKnownHostExecute(r)
}

/*
CreateRepositoryPipelineKnownHost Create a known host

Create a repository level known host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiCreateRepositoryPipelineKnownHostRequest
*/
func (a *PipelinesApiService) CreateRepositoryPipelineKnownHost(ctx context.Context, workspace string, repoSlug string) PipelinesApiCreateRepositoryPipelineKnownHostRequest {
	return PipelinesApiCreateRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelineKnownHost
func (a *PipelinesApiService) CreateRepositoryPipelineKnownHostExecute(r PipelinesApiCreateRepositoryPipelineKnownHostRequest) (*PipelineKnownHost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineKnownHost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateRepositoryPipelineKnownHost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiCreateRepositoryPipelineScheduleRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	body *PipelineSchedule
}

// The schedule to create.
func (r PipelinesApiCreateRepositoryPipelineScheduleRequest) Body(body PipelineSchedule) PipelinesApiCreateRepositoryPipelineScheduleRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreateRepositoryPipelineScheduleRequest) Execute() (*PipelineSchedule, *http.Response, error) {
	return r.ApiService.CreateRepositoryPipelineScheduleExecute(r)
}

/*
CreateRepositoryPipelineSchedule Create a schedule

Create a schedule for the given repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiCreateRepositoryPipelineScheduleRequest
*/
func (a *PipelinesApiService) CreateRepositoryPipelineSchedule(ctx context.Context, workspace string, repoSlug string) PipelinesApiCreateRepositoryPipelineScheduleRequest {
	return PipelinesApiCreateRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelineSchedule
func (a *PipelinesApiService) CreateRepositoryPipelineScheduleExecute(r PipelinesApiCreateRepositoryPipelineScheduleRequest) (*PipelineSchedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateRepositoryPipelineSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiCreateRepositoryPipelineVariableRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	body *PipelineVariable
}

// The variable to create.
func (r PipelinesApiCreateRepositoryPipelineVariableRequest) Body(body PipelineVariable) PipelinesApiCreateRepositoryPipelineVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiCreateRepositoryPipelineVariableRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.CreateRepositoryPipelineVariableExecute(r)
}

/*
CreateRepositoryPipelineVariable Create a variable for a repository

Create a repository level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiCreateRepositoryPipelineVariableRequest
*/
func (a *PipelinesApiService) CreateRepositoryPipelineVariable(ctx context.Context, workspace string, repoSlug string) PipelinesApiCreateRepositoryPipelineVariableRequest {
	return PipelinesApiCreateRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelineVariable
func (a *PipelinesApiService) CreateRepositoryPipelineVariableExecute(r PipelinesApiCreateRepositoryPipelineVariableRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.CreateRepositoryPipelineVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiDeleteDeploymentVariableRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	environmentUuid string
	variableUuid string
}

func (r PipelinesApiDeleteDeploymentVariableRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDeploymentVariableExecute(r)
}

/*
DeleteDeploymentVariable Delete a variable for an environment

Delete a deployment environment level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param environmentUuid The environment.
 @param variableUuid The UUID of the variable to delete.
 @return PipelinesApiDeleteDeploymentVariableRequest
*/
func (a *PipelinesApiService) DeleteDeploymentVariable(ctx context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiDeleteDeploymentVariableRequest {
	return PipelinesApiDeleteDeploymentVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) DeleteDeploymentVariableExecute(r PipelinesApiDeleteDeploymentVariableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteDeploymentVariable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", url.PathEscape(parameterToString(r.environmentUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeletePipelineVariableForTeamRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	username string
	variableUuid string
}

func (r PipelinesApiDeletePipelineVariableForTeamRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePipelineVariableForTeamExecute(r)
}

/*
DeletePipelineVariableForTeam Delete a variable for a team

Delete a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The account.
 @param variableUuid The UUID of the variable to delete.
 @return PipelinesApiDeletePipelineVariableForTeamRequest

Deprecated
*/
func (a *PipelinesApiService) DeletePipelineVariableForTeam(ctx context.Context, username string, variableUuid string) PipelinesApiDeletePipelineVariableForTeamRequest {
	return PipelinesApiDeletePipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
// Deprecated
func (a *PipelinesApiService) DeletePipelineVariableForTeamExecute(r PipelinesApiDeletePipelineVariableForTeamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeletePipelineVariableForTeam")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeletePipelineVariableForUserRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	selectedUser string
	variableUuid string
}

func (r PipelinesApiDeletePipelineVariableForUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePipelineVariableForUserExecute(r)
}

/*
DeletePipelineVariableForUser Delete a variable for a user

Delete an account level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 @param variableUuid The UUID of the variable to delete.
 @return PipelinesApiDeletePipelineVariableForUserRequest

Deprecated
*/
func (a *PipelinesApiService) DeletePipelineVariableForUser(ctx context.Context, selectedUser string, variableUuid string) PipelinesApiDeletePipelineVariableForUserRequest {
	return PipelinesApiDeletePipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
// Deprecated
func (a *PipelinesApiService) DeletePipelineVariableForUserExecute(r PipelinesApiDeletePipelineVariableForUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeletePipelineVariableForUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", url.PathEscape(parameterToString(r.selectedUser, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeletePipelineVariableForWorkspaceRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	variableUuid string
}

func (r PipelinesApiDeletePipelineVariableForWorkspaceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePipelineVariableForWorkspaceExecute(r)
}

/*
DeletePipelineVariableForWorkspace Delete a variable for a workspace

Delete a workspace level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param variableUuid The UUID of the variable to delete.
 @return PipelinesApiDeletePipelineVariableForWorkspaceRequest
*/
func (a *PipelinesApiService) DeletePipelineVariableForWorkspace(ctx context.Context, workspace string, variableUuid string) PipelinesApiDeletePipelineVariableForWorkspaceRequest {
	return PipelinesApiDeletePipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) DeletePipelineVariableForWorkspaceExecute(r PipelinesApiDeletePipelineVariableForWorkspaceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeletePipelineVariableForWorkspace")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeleteRepositoryPipelineCacheRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	cacheUuid string
}

func (r PipelinesApiDeleteRepositoryPipelineCacheRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineCacheExecute(r)
}

/*
DeleteRepositoryPipelineCache Delete a cache

Delete a repository cache.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace The account.
 @param repoSlug The repository.
 @param cacheUuid The UUID of the cache to delete.
 @return PipelinesApiDeleteRepositoryPipelineCacheRequest
*/
func (a *PipelinesApiService) DeleteRepositoryPipelineCache(ctx context.Context, workspace string, repoSlug string, cacheUuid string) PipelinesApiDeleteRepositoryPipelineCacheRequest {
	return PipelinesApiDeleteRepositoryPipelineCacheRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		cacheUuid: cacheUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) DeleteRepositoryPipelineCacheExecute(r PipelinesApiDeleteRepositoryPipelineCacheRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineCache")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cache_uuid"+"}", url.PathEscape(parameterToString(r.cacheUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeleteRepositoryPipelineKeyPairRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiDeleteRepositoryPipelineKeyPairRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineKeyPairExecute(r)
}

/*
DeleteRepositoryPipelineKeyPair Delete SSH key pair

Delete the repository SSH key pair.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiDeleteRepositoryPipelineKeyPairRequest
*/
func (a *PipelinesApiService) DeleteRepositoryPipelineKeyPair(ctx context.Context, workspace string, repoSlug string) PipelinesApiDeleteRepositoryPipelineKeyPairRequest {
	return PipelinesApiDeleteRepositoryPipelineKeyPairRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
func (a *PipelinesApiService) DeleteRepositoryPipelineKeyPairExecute(r PipelinesApiDeleteRepositoryPipelineKeyPairRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineKeyPair")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeleteRepositoryPipelineKnownHostRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	knownHostUuid string
}

func (r PipelinesApiDeleteRepositoryPipelineKnownHostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineKnownHostExecute(r)
}

/*
DeleteRepositoryPipelineKnownHost Delete a known host

Delete a repository level known host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param knownHostUuid The UUID of the known host to delete.
 @return PipelinesApiDeleteRepositoryPipelineKnownHostRequest
*/
func (a *PipelinesApiService) DeleteRepositoryPipelineKnownHost(ctx context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiDeleteRepositoryPipelineKnownHostRequest {
	return PipelinesApiDeleteRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		knownHostUuid: knownHostUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) DeleteRepositoryPipelineKnownHostExecute(r PipelinesApiDeleteRepositoryPipelineKnownHostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineKnownHost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"known_host_uuid"+"}", url.PathEscape(parameterToString(r.knownHostUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeleteRepositoryPipelineScheduleRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	scheduleUuid string
}

func (r PipelinesApiDeleteRepositoryPipelineScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineScheduleExecute(r)
}

/*
DeleteRepositoryPipelineSchedule Delete a schedule

Delete a schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param scheduleUuid The uuid of the schedule.
 @return PipelinesApiDeleteRepositoryPipelineScheduleRequest
*/
func (a *PipelinesApiService) DeleteRepositoryPipelineSchedule(ctx context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiDeleteRepositoryPipelineScheduleRequest {
	return PipelinesApiDeleteRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) DeleteRepositoryPipelineScheduleExecute(r PipelinesApiDeleteRepositoryPipelineScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", url.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiDeleteRepositoryPipelineVariableRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	variableUuid string
}

func (r PipelinesApiDeleteRepositoryPipelineVariableRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRepositoryPipelineVariableExecute(r)
}

/*
DeleteRepositoryPipelineVariable Delete a variable for a repository

Delete a repository level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param variableUuid The UUID of the variable to delete.
 @return PipelinesApiDeleteRepositoryPipelineVariableRequest
*/
func (a *PipelinesApiService) DeleteRepositoryPipelineVariable(ctx context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiDeleteRepositoryPipelineVariableRequest {
	return PipelinesApiDeleteRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) DeleteRepositoryPipelineVariableExecute(r PipelinesApiDeleteRepositoryPipelineVariableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.DeleteRepositoryPipelineVariable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetDeploymentVariablesRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	environmentUuid string
}

func (r PipelinesApiGetDeploymentVariablesRequest) Execute() (*PaginatedDeploymentVariable, *http.Response, error) {
	return r.ApiService.GetDeploymentVariablesExecute(r)
}

/*
GetDeploymentVariables List variables for an environment

Find deployment environment level variables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param environmentUuid The environment.
 @return PipelinesApiGetDeploymentVariablesRequest
*/
func (a *PipelinesApiService) GetDeploymentVariables(ctx context.Context, workspace string, repoSlug string, environmentUuid string) PipelinesApiGetDeploymentVariablesRequest {
	return PipelinesApiGetDeploymentVariablesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
	}
}

// Execute executes the request
//  @return PaginatedDeploymentVariable
func (a *PipelinesApiService) GetDeploymentVariablesExecute(r PipelinesApiGetDeploymentVariablesRequest) (*PaginatedDeploymentVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeploymentVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetDeploymentVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", url.PathEscape(parameterToString(r.environmentUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetOIDCConfigurationRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
}

func (r PipelinesApiGetOIDCConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetOIDCConfigurationExecute(r)
}

/*
GetOIDCConfiguration Get OpenID configuration for OIDC in Pipelines

This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @return PipelinesApiGetOIDCConfigurationRequest
*/
func (a *PipelinesApiService) GetOIDCConfiguration(ctx context.Context, workspace string) PipelinesApiGetOIDCConfigurationRequest {
	return PipelinesApiGetOIDCConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

// Execute executes the request
func (a *PipelinesApiService) GetOIDCConfigurationExecute(r PipelinesApiGetOIDCConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetOIDCConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/identity/oidc/.well-known/openid-configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetOIDCKeysRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
}

func (r PipelinesApiGetOIDCKeysRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetOIDCKeysExecute(r)
}

/*
GetOIDCKeys Get keys for OIDC in Pipelines

This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @return PipelinesApiGetOIDCKeysRequest
*/
func (a *PipelinesApiService) GetOIDCKeys(ctx context.Context, workspace string) PipelinesApiGetOIDCKeysRequest {
	return PipelinesApiGetOIDCKeysRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

// Execute executes the request
func (a *PipelinesApiService) GetOIDCKeysExecute(r PipelinesApiGetOIDCKeysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetOIDCKeys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/identity/oidc/keys.json"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineContainerLogRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
	logUuid string
}

func (r PipelinesApiGetPipelineContainerLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPipelineContainerLogExecute(r)
}

/*
GetPipelineContainerLog Get the logs for the build container or a service container for a given step of a pipeline.

Retrieve the log file for a build container or service container.

This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @param stepUuid The UUID of the step.
 @param logUuid For the main build container specify the step UUID; for a service container specify the service container UUID
 @return PipelinesApiGetPipelineContainerLogRequest
*/
func (a *PipelinesApiService) GetPipelineContainerLog(ctx context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string, logUuid string) PipelinesApiGetPipelineContainerLogRequest {
	return PipelinesApiGetPipelineContainerLogRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
		logUuid: logUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) GetPipelineContainerLogExecute(r PipelinesApiGetPipelineContainerLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineContainerLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/logs/{log_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", url.PathEscape(parameterToString(r.stepUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"log_uuid"+"}", url.PathEscape(parameterToString(r.logUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineForRepositoryRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
}

func (r PipelinesApiGetPipelineForRepositoryRequest) Execute() (*Pipeline, *http.Response, error) {
	return r.ApiService.GetPipelineForRepositoryExecute(r)
}

/*
GetPipelineForRepository Get a pipeline

Retrieve a specified pipeline

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The pipeline UUID.
 @return PipelinesApiGetPipelineForRepositoryRequest
*/
func (a *PipelinesApiService) GetPipelineForRepository(ctx context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiGetPipelineForRepositoryRequest {
	return PipelinesApiGetPipelineForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
	}
}

// Execute executes the request
//  @return Pipeline
func (a *PipelinesApiService) GetPipelineForRepositoryExecute(r PipelinesApiGetPipelineForRepositoryRequest) (*Pipeline, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pipeline
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineStepForRepositoryRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
}

func (r PipelinesApiGetPipelineStepForRepositoryRequest) Execute() (*PipelineStep, *http.Response, error) {
	return r.ApiService.GetPipelineStepForRepositoryExecute(r)
}

/*
GetPipelineStepForRepository Get a step of a pipeline

Retrieve a given step of a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @param stepUuid The UUID of the step.
 @return PipelinesApiGetPipelineStepForRepositoryRequest
*/
func (a *PipelinesApiService) GetPipelineStepForRepository(ctx context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiGetPipelineStepForRepositoryRequest {
	return PipelinesApiGetPipelineStepForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
	}
}

// Execute executes the request
//  @return PipelineStep
func (a *PipelinesApiService) GetPipelineStepForRepositoryExecute(r PipelinesApiGetPipelineStepForRepositoryRequest) (*PipelineStep, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineStep
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineStepForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", url.PathEscape(parameterToString(r.stepUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineStepLogForRepositoryRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
}

func (r PipelinesApiGetPipelineStepLogForRepositoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPipelineStepLogForRepositoryExecute(r)
}

/*
GetPipelineStepLogForRepository Get log file for a step

Retrieve the log file for a given step of a pipeline.

This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @param stepUuid The UUID of the step.
 @return PipelinesApiGetPipelineStepLogForRepositoryRequest
*/
func (a *PipelinesApiService) GetPipelineStepLogForRepository(ctx context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiGetPipelineStepLogForRepositoryRequest {
	return PipelinesApiGetPipelineStepLogForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) GetPipelineStepLogForRepositoryExecute(r PipelinesApiGetPipelineStepLogForRepositoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineStepLogForRepository")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", url.PathEscape(parameterToString(r.stepUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 416 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 304 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineStepsForRepositoryRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
}

func (r PipelinesApiGetPipelineStepsForRepositoryRequest) Execute() (*PaginatedPipelineSteps, *http.Response, error) {
	return r.ApiService.GetPipelineStepsForRepositoryExecute(r)
}

/*
GetPipelineStepsForRepository List steps for a pipeline

Find steps for the given pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @return PipelinesApiGetPipelineStepsForRepositoryRequest
*/
func (a *PipelinesApiService) GetPipelineStepsForRepository(ctx context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiGetPipelineStepsForRepositoryRequest {
	return PipelinesApiGetPipelineStepsForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
	}
}

// Execute executes the request
//  @return PaginatedPipelineSteps
func (a *PipelinesApiService) GetPipelineStepsForRepositoryExecute(r PipelinesApiGetPipelineStepsForRepositoryRequest) (*PaginatedPipelineSteps, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineSteps
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineStepsForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineTestReportTestCaseReasonsRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
	testCaseUuid string
}

func (r PipelinesApiGetPipelineTestReportTestCaseReasonsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPipelineTestReportTestCaseReasonsExecute(r)
}

/*
GetPipelineTestReportTestCaseReasons Get test case reasons (output) for a given test case in a step of a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @param stepUuid The UUID of the step.
 @param testCaseUuid The UUID of the test case.
 @return PipelinesApiGetPipelineTestReportTestCaseReasonsRequest
*/
func (a *PipelinesApiService) GetPipelineTestReportTestCaseReasons(ctx context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string, testCaseUuid string) PipelinesApiGetPipelineTestReportTestCaseReasonsRequest {
	return PipelinesApiGetPipelineTestReportTestCaseReasonsRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
		testCaseUuid: testCaseUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) GetPipelineTestReportTestCaseReasonsExecute(r PipelinesApiGetPipelineTestReportTestCaseReasonsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineTestReportTestCaseReasons")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases/{test_case_uuid}/test_case_reasons"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", url.PathEscape(parameterToString(r.stepUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"test_case_uuid"+"}", url.PathEscape(parameterToString(r.testCaseUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineTestReportTestCasesRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
}

func (r PipelinesApiGetPipelineTestReportTestCasesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPipelineTestReportTestCasesExecute(r)
}

/*
GetPipelineTestReportTestCases Get test cases for a given step of a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @param stepUuid The UUID of the step.
 @return PipelinesApiGetPipelineTestReportTestCasesRequest
*/
func (a *PipelinesApiService) GetPipelineTestReportTestCases(ctx context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiGetPipelineTestReportTestCasesRequest {
	return PipelinesApiGetPipelineTestReportTestCasesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) GetPipelineTestReportTestCasesExecute(r PipelinesApiGetPipelineTestReportTestCasesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineTestReportTestCases")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", url.PathEscape(parameterToString(r.stepUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineTestReportsRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
	stepUuid string
}

func (r PipelinesApiGetPipelineTestReportsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPipelineTestReportsExecute(r)
}

/*
GetPipelineTestReports Get a summary of test reports for a given step of a pipeline.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @param stepUuid The UUID of the step.
 @return PipelinesApiGetPipelineTestReportsRequest
*/
func (a *PipelinesApiService) GetPipelineTestReports(ctx context.Context, workspace string, repoSlug string, pipelineUuid string, stepUuid string) PipelinesApiGetPipelineTestReportsRequest {
	return PipelinesApiGetPipelineTestReportsRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
		stepUuid: stepUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) GetPipelineTestReportsExecute(r PipelinesApiGetPipelineTestReportsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineTestReports")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"step_uuid"+"}", url.PathEscape(parameterToString(r.stepUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineVariableForTeamRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	username string
	variableUuid string
}

func (r PipelinesApiGetPipelineVariableForTeamRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.GetPipelineVariableForTeamExecute(r)
}

/*
GetPipelineVariableForTeam Get a variable for a team

Retrieve a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The account.
 @param variableUuid The UUID of the variable to retrieve.
 @return PipelinesApiGetPipelineVariableForTeamRequest

Deprecated
*/
func (a *PipelinesApiService) GetPipelineVariableForTeam(ctx context.Context, username string, variableUuid string) PipelinesApiGetPipelineVariableForTeamRequest {
	return PipelinesApiGetPipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
// Deprecated
func (a *PipelinesApiService) GetPipelineVariableForTeamExecute(r PipelinesApiGetPipelineVariableForTeamRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariableForTeam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineVariableForUserRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	selectedUser string
	variableUuid string
}

func (r PipelinesApiGetPipelineVariableForUserRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.GetPipelineVariableForUserExecute(r)
}

/*
GetPipelineVariableForUser Get a variable for a user

Retrieve a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 @param variableUuid The UUID of the variable to retrieve.
 @return PipelinesApiGetPipelineVariableForUserRequest

Deprecated
*/
func (a *PipelinesApiService) GetPipelineVariableForUser(ctx context.Context, selectedUser string, variableUuid string) PipelinesApiGetPipelineVariableForUserRequest {
	return PipelinesApiGetPipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
// Deprecated
func (a *PipelinesApiService) GetPipelineVariableForUserExecute(r PipelinesApiGetPipelineVariableForUserRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariableForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", url.PathEscape(parameterToString(r.selectedUser, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineVariableForWorkspaceRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	variableUuid string
}

func (r PipelinesApiGetPipelineVariableForWorkspaceRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.GetPipelineVariableForWorkspaceExecute(r)
}

/*
GetPipelineVariableForWorkspace Get variable for a workspace

Retrieve a workspace level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param variableUuid The UUID of the variable to retrieve.
 @return PipelinesApiGetPipelineVariableForWorkspaceRequest
*/
func (a *PipelinesApiService) GetPipelineVariableForWorkspace(ctx context.Context, workspace string, variableUuid string) PipelinesApiGetPipelineVariableForWorkspaceRequest {
	return PipelinesApiGetPipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
func (a *PipelinesApiService) GetPipelineVariableForWorkspaceExecute(r PipelinesApiGetPipelineVariableForWorkspaceRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariableForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineVariablesForTeamRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	username string
}

func (r PipelinesApiGetPipelineVariablesForTeamRequest) Execute() (*PaginatedPipelineVariables, *http.Response, error) {
	return r.ApiService.GetPipelineVariablesForTeamExecute(r)
}

/*
GetPipelineVariablesForTeam List variables for an account

Find account level variables.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The account.
 @return PipelinesApiGetPipelineVariablesForTeamRequest

Deprecated
*/
func (a *PipelinesApiService) GetPipelineVariablesForTeam(ctx context.Context, username string) PipelinesApiGetPipelineVariablesForTeamRequest {
	return PipelinesApiGetPipelineVariablesForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return PaginatedPipelineVariables
// Deprecated
func (a *PipelinesApiService) GetPipelineVariablesForTeamExecute(r PipelinesApiGetPipelineVariablesForTeamRequest) (*PaginatedPipelineVariables, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariablesForTeam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineVariablesForUserRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	selectedUser string
}

func (r PipelinesApiGetPipelineVariablesForUserRequest) Execute() (*PaginatedPipelineVariables, *http.Response, error) {
	return r.ApiService.GetPipelineVariablesForUserExecute(r)
}

/*
GetPipelineVariablesForUser List variables for a user

Find user level variables.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 @return PipelinesApiGetPipelineVariablesForUserRequest

Deprecated
*/
func (a *PipelinesApiService) GetPipelineVariablesForUser(ctx context.Context, selectedUser string) PipelinesApiGetPipelineVariablesForUserRequest {
	return PipelinesApiGetPipelineVariablesForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
	}
}

// Execute executes the request
//  @return PaginatedPipelineVariables
// Deprecated
func (a *PipelinesApiService) GetPipelineVariablesForUserExecute(r PipelinesApiGetPipelineVariablesForUserRequest) (*PaginatedPipelineVariables, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariablesForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", url.PathEscape(parameterToString(r.selectedUser, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelineVariablesForWorkspaceRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
}

func (r PipelinesApiGetPipelineVariablesForWorkspaceRequest) Execute() (*PaginatedPipelineVariables, *http.Response, error) {
	return r.ApiService.GetPipelineVariablesForWorkspaceExecute(r)
}

/*
GetPipelineVariablesForWorkspace List variables for a workspace

Find workspace level variables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @return PipelinesApiGetPipelineVariablesForWorkspaceRequest
*/
func (a *PipelinesApiService) GetPipelineVariablesForWorkspace(ctx context.Context, workspace string) PipelinesApiGetPipelineVariablesForWorkspaceRequest {
	return PipelinesApiGetPipelineVariablesForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
	}
}

// Execute executes the request
//  @return PaginatedPipelineVariables
func (a *PipelinesApiService) GetPipelineVariablesForWorkspaceExecute(r PipelinesApiGetPipelineVariablesForWorkspaceRequest) (*PaginatedPipelineVariables, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelineVariablesForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetPipelinesForRepositoryRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiGetPipelinesForRepositoryRequest) Execute() (*PaginatedPipelines, *http.Response, error) {
	return r.ApiService.GetPipelinesForRepositoryExecute(r)
}

/*
GetPipelinesForRepository List pipelines

Find pipelines

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiGetPipelinesForRepositoryRequest
*/
func (a *PipelinesApiService) GetPipelinesForRepository(ctx context.Context, workspace string, repoSlug string) PipelinesApiGetPipelinesForRepositoryRequest {
	return PipelinesApiGetPipelinesForRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PaginatedPipelines
func (a *PipelinesApiService) GetPipelinesForRepositoryExecute(r PipelinesApiGetPipelinesForRepositoryRequest) (*PaginatedPipelines, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelines
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetPipelinesForRepository")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineCacheContentURIRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	cacheUuid string
}

func (r PipelinesApiGetRepositoryPipelineCacheContentURIRequest) Execute() (*PipelineCacheContentUri, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineCacheContentURIExecute(r)
}

/*
GetRepositoryPipelineCacheContentURI Get cache content URI

Retrieve the URI of the content of the specified cache.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace The account.
 @param repoSlug The repository.
 @param cacheUuid The UUID of the cache.
 @return PipelinesApiGetRepositoryPipelineCacheContentURIRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineCacheContentURI(ctx context.Context, workspace string, repoSlug string, cacheUuid string) PipelinesApiGetRepositoryPipelineCacheContentURIRequest {
	return PipelinesApiGetRepositoryPipelineCacheContentURIRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		cacheUuid: cacheUuid,
	}
}

// Execute executes the request
//  @return PipelineCacheContentUri
func (a *PipelinesApiService) GetRepositoryPipelineCacheContentURIExecute(r PipelinesApiGetRepositoryPipelineCacheContentURIRequest) (*PipelineCacheContentUri, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineCacheContentUri
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineCacheContentURI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}/content-uri"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cache_uuid"+"}", url.PathEscape(parameterToString(r.cacheUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineCachesRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiGetRepositoryPipelineCachesRequest) Execute() (*PaginatedPipelineCaches, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineCachesExecute(r)
}

/*
GetRepositoryPipelineCaches List caches

Retrieve the repository pipelines caches.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace The account.
 @param repoSlug The repository.
 @return PipelinesApiGetRepositoryPipelineCachesRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineCaches(ctx context.Context, workspace string, repoSlug string) PipelinesApiGetRepositoryPipelineCachesRequest {
	return PipelinesApiGetRepositoryPipelineCachesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PaginatedPipelineCaches
func (a *PipelinesApiService) GetRepositoryPipelineCachesExecute(r PipelinesApiGetRepositoryPipelineCachesRequest) (*PaginatedPipelineCaches, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineCaches
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineCaches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines-config/caches/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineConfigRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiGetRepositoryPipelineConfigRequest) Execute() (*PipelinesConfig, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineConfigExecute(r)
}

/*
GetRepositoryPipelineConfig Get configuration

Retrieve the repository pipelines configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace The account.
 @param repoSlug The repository.
 @return PipelinesApiGetRepositoryPipelineConfigRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineConfig(ctx context.Context, workspace string, repoSlug string) PipelinesApiGetRepositoryPipelineConfigRequest {
	return PipelinesApiGetRepositoryPipelineConfigRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelinesConfig
func (a *PipelinesApiService) GetRepositoryPipelineConfigExecute(r PipelinesApiGetRepositoryPipelineConfigRequest) (*PipelinesConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelinesConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineKnownHostRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	knownHostUuid string
}

func (r PipelinesApiGetRepositoryPipelineKnownHostRequest) Execute() (*PipelineKnownHost, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineKnownHostExecute(r)
}

/*
GetRepositoryPipelineKnownHost Get a known host

Retrieve a repository level known host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param knownHostUuid The UUID of the known host to retrieve.
 @return PipelinesApiGetRepositoryPipelineKnownHostRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineKnownHost(ctx context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiGetRepositoryPipelineKnownHostRequest {
	return PipelinesApiGetRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		knownHostUuid: knownHostUuid,
	}
}

// Execute executes the request
//  @return PipelineKnownHost
func (a *PipelinesApiService) GetRepositoryPipelineKnownHostExecute(r PipelinesApiGetRepositoryPipelineKnownHostRequest) (*PipelineKnownHost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineKnownHost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineKnownHost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"known_host_uuid"+"}", url.PathEscape(parameterToString(r.knownHostUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineKnownHostsRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiGetRepositoryPipelineKnownHostsRequest) Execute() (*PaginatedPipelineKnownHosts, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineKnownHostsExecute(r)
}

/*
GetRepositoryPipelineKnownHosts List known hosts

Find repository level known hosts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiGetRepositoryPipelineKnownHostsRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineKnownHosts(ctx context.Context, workspace string, repoSlug string) PipelinesApiGetRepositoryPipelineKnownHostsRequest {
	return PipelinesApiGetRepositoryPipelineKnownHostsRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PaginatedPipelineKnownHosts
func (a *PipelinesApiService) GetRepositoryPipelineKnownHostsExecute(r PipelinesApiGetRepositoryPipelineKnownHostsRequest) (*PaginatedPipelineKnownHosts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineKnownHosts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineKnownHosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineScheduleRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	scheduleUuid string
}

func (r PipelinesApiGetRepositoryPipelineScheduleRequest) Execute() (*PipelineSchedule, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineScheduleExecute(r)
}

/*
GetRepositoryPipelineSchedule Get a schedule

Retrieve a schedule by its UUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param scheduleUuid The uuid of the schedule.
 @return PipelinesApiGetRepositoryPipelineScheduleRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineSchedule(ctx context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiGetRepositoryPipelineScheduleRequest {
	return PipelinesApiGetRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

// Execute executes the request
//  @return PipelineSchedule
func (a *PipelinesApiService) GetRepositoryPipelineScheduleExecute(r PipelinesApiGetRepositoryPipelineScheduleRequest) (*PipelineSchedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", url.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	scheduleUuid string
}

func (r PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest) Execute() (*PaginatedPipelineScheduleExecutions, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineScheduleExecutionsExecute(r)
}

/*
GetRepositoryPipelineScheduleExecutions List executions of a schedule

Retrieve the executions of a given schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param scheduleUuid The uuid of the schedule.
 @return PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineScheduleExecutions(ctx context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest {
	return PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

// Execute executes the request
//  @return PaginatedPipelineScheduleExecutions
func (a *PipelinesApiService) GetRepositoryPipelineScheduleExecutionsExecute(r PipelinesApiGetRepositoryPipelineScheduleExecutionsRequest) (*PaginatedPipelineScheduleExecutions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineScheduleExecutions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineScheduleExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", url.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineSchedulesRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiGetRepositoryPipelineSchedulesRequest) Execute() (*PaginatedPipelineSchedules, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineSchedulesExecute(r)
}

/*
GetRepositoryPipelineSchedules List schedules

Retrieve the configured schedules for the given repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiGetRepositoryPipelineSchedulesRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineSchedules(ctx context.Context, workspace string, repoSlug string) PipelinesApiGetRepositoryPipelineSchedulesRequest {
	return PipelinesApiGetRepositoryPipelineSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PaginatedPipelineSchedules
func (a *PipelinesApiService) GetRepositoryPipelineSchedulesExecute(r PipelinesApiGetRepositoryPipelineSchedulesRequest) (*PaginatedPipelineSchedules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineSchedules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineSshKeyPairRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiGetRepositoryPipelineSshKeyPairRequest) Execute() (*PipelineSshKeyPair, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineSshKeyPairExecute(r)
}

/*
GetRepositoryPipelineSshKeyPair Get SSH key pair

Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiGetRepositoryPipelineSshKeyPairRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineSshKeyPair(ctx context.Context, workspace string, repoSlug string) PipelinesApiGetRepositoryPipelineSshKeyPairRequest {
	return PipelinesApiGetRepositoryPipelineSshKeyPairRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelineSshKeyPair
func (a *PipelinesApiService) GetRepositoryPipelineSshKeyPairExecute(r PipelinesApiGetRepositoryPipelineSshKeyPairRequest) (*PipelineSshKeyPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineSshKeyPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineSshKeyPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineVariableRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	variableUuid string
}

func (r PipelinesApiGetRepositoryPipelineVariableRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineVariableExecute(r)
}

/*
GetRepositoryPipelineVariable Get a variable for a repository

Retrieve a repository level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param variableUuid The UUID of the variable to retrieve.
 @return PipelinesApiGetRepositoryPipelineVariableRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineVariable(ctx context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiGetRepositoryPipelineVariableRequest {
	return PipelinesApiGetRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
func (a *PipelinesApiService) GetRepositoryPipelineVariableExecute(r PipelinesApiGetRepositoryPipelineVariableRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiGetRepositoryPipelineVariablesRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
}

func (r PipelinesApiGetRepositoryPipelineVariablesRequest) Execute() (*PaginatedPipelineVariables, *http.Response, error) {
	return r.ApiService.GetRepositoryPipelineVariablesExecute(r)
}

/*
GetRepositoryPipelineVariables List variables for a repository

Find repository level variables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiGetRepositoryPipelineVariablesRequest
*/
func (a *PipelinesApiService) GetRepositoryPipelineVariables(ctx context.Context, workspace string, repoSlug string) PipelinesApiGetRepositoryPipelineVariablesRequest {
	return PipelinesApiGetRepositoryPipelineVariablesRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PaginatedPipelineVariables
func (a *PipelinesApiService) GetRepositoryPipelineVariablesExecute(r PipelinesApiGetRepositoryPipelineVariablesRequest) (*PaginatedPipelineVariables, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPipelineVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.GetRepositoryPipelineVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiStopPipelineRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	pipelineUuid string
}

func (r PipelinesApiStopPipelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopPipelineExecute(r)
}

/*
StopPipeline Stop a pipeline

Signal the stop of a pipeline and all of its steps that not have completed yet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param pipelineUuid The UUID of the pipeline.
 @return PipelinesApiStopPipelineRequest
*/
func (a *PipelinesApiService) StopPipeline(ctx context.Context, workspace string, repoSlug string, pipelineUuid string) PipelinesApiStopPipelineRequest {
	return PipelinesApiStopPipelineRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		pipelineUuid: pipelineUuid,
	}
}

// Execute executes the request
func (a *PipelinesApiService) StopPipelineExecute(r PipelinesApiStopPipelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.StopPipeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_uuid"+"}", url.PathEscape(parameterToString(r.pipelineUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PipelinesApiUpdateDeploymentVariableRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	environmentUuid string
	variableUuid string
	body *DeploymentVariable
}

// The updated deployment variable.
func (r PipelinesApiUpdateDeploymentVariableRequest) Body(body DeploymentVariable) PipelinesApiUpdateDeploymentVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdateDeploymentVariableRequest) Execute() (*DeploymentVariable, *http.Response, error) {
	return r.ApiService.UpdateDeploymentVariableExecute(r)
}

/*
UpdateDeploymentVariable Update a variable for an environment

Update a deployment environment level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param environmentUuid The environment.
 @param variableUuid The UUID of the variable to update.
 @return PipelinesApiUpdateDeploymentVariableRequest
*/
func (a *PipelinesApiService) UpdateDeploymentVariable(ctx context.Context, workspace string, repoSlug string, environmentUuid string, variableUuid string) PipelinesApiUpdateDeploymentVariableRequest {
	return PipelinesApiUpdateDeploymentVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		environmentUuid: environmentUuid,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return DeploymentVariable
func (a *PipelinesApiService) UpdateDeploymentVariableExecute(r PipelinesApiUpdateDeploymentVariableRequest) (*DeploymentVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploymentVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateDeploymentVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"environment_uuid"+"}", url.PathEscape(parameterToString(r.environmentUuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdatePipelineVariableForTeamRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	username string
	variableUuid string
	body *PipelineVariable
}

// The updated variable.
func (r PipelinesApiUpdatePipelineVariableForTeamRequest) Body(body PipelineVariable) PipelinesApiUpdatePipelineVariableForTeamRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdatePipelineVariableForTeamRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.UpdatePipelineVariableForTeamExecute(r)
}

/*
UpdatePipelineVariableForTeam Update a variable for a team

Update a team level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The account.
 @param variableUuid The UUID of the variable.
 @return PipelinesApiUpdatePipelineVariableForTeamRequest

Deprecated
*/
func (a *PipelinesApiService) UpdatePipelineVariableForTeam(ctx context.Context, username string, variableUuid string) PipelinesApiUpdatePipelineVariableForTeamRequest {
	return PipelinesApiUpdatePipelineVariableForTeamRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
// Deprecated
func (a *PipelinesApiService) UpdatePipelineVariableForTeamExecute(r PipelinesApiUpdatePipelineVariableForTeamRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdatePipelineVariableForTeam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/teams/{username}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdatePipelineVariableForUserRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	selectedUser string
	variableUuid string
	body *PipelineVariable
}

// The updated variable.
func (r PipelinesApiUpdatePipelineVariableForUserRequest) Body(body PipelineVariable) PipelinesApiUpdatePipelineVariableForUserRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdatePipelineVariableForUserRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.UpdatePipelineVariableForUserExecute(r)
}

/*
UpdatePipelineVariableForUser Update a variable for a user

Update a user level variable.
This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param selectedUser Either the UUID of the account surrounded by curly-braces, for example `{account UUID}`, OR an Atlassian Account ID.
 @param variableUuid The UUID of the variable.
 @return PipelinesApiUpdatePipelineVariableForUserRequest

Deprecated
*/
func (a *PipelinesApiService) UpdatePipelineVariableForUser(ctx context.Context, selectedUser string, variableUuid string) PipelinesApiUpdatePipelineVariableForUserRequest {
	return PipelinesApiUpdatePipelineVariableForUserRequest{
		ApiService: a,
		ctx: ctx,
		selectedUser: selectedUser,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
// Deprecated
func (a *PipelinesApiService) UpdatePipelineVariableForUserExecute(r PipelinesApiUpdatePipelineVariableForUserRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdatePipelineVariableForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{selected_user}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"selected_user"+"}", url.PathEscape(parameterToString(r.selectedUser, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdatePipelineVariableForWorkspaceRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	variableUuid string
	body *PipelineVariable
}

// The updated variable.
func (r PipelinesApiUpdatePipelineVariableForWorkspaceRequest) Body(body PipelineVariable) PipelinesApiUpdatePipelineVariableForWorkspaceRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdatePipelineVariableForWorkspaceRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.UpdatePipelineVariableForWorkspaceExecute(r)
}

/*
UpdatePipelineVariableForWorkspace Update variable for a workspace

Update a workspace level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param variableUuid The UUID of the variable.
 @return PipelinesApiUpdatePipelineVariableForWorkspaceRequest
*/
func (a *PipelinesApiService) UpdatePipelineVariableForWorkspace(ctx context.Context, workspace string, variableUuid string) PipelinesApiUpdatePipelineVariableForWorkspaceRequest {
	return PipelinesApiUpdatePipelineVariableForWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
func (a *PipelinesApiService) UpdatePipelineVariableForWorkspaceExecute(r PipelinesApiUpdatePipelineVariableForWorkspaceRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdatePipelineVariableForWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdateRepositoryBuildNumberRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	body *PipelineBuildNumber
}

// The build number to update.
func (r PipelinesApiUpdateRepositoryBuildNumberRequest) Body(body PipelineBuildNumber) PipelinesApiUpdateRepositoryBuildNumberRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdateRepositoryBuildNumberRequest) Execute() (*PipelineBuildNumber, *http.Response, error) {
	return r.ApiService.UpdateRepositoryBuildNumberExecute(r)
}

/*
UpdateRepositoryBuildNumber Update the next build number

Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiUpdateRepositoryBuildNumberRequest
*/
func (a *PipelinesApiService) UpdateRepositoryBuildNumber(ctx context.Context, workspace string, repoSlug string) PipelinesApiUpdateRepositoryBuildNumberRequest {
	return PipelinesApiUpdateRepositoryBuildNumberRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelineBuildNumber
func (a *PipelinesApiService) UpdateRepositoryBuildNumberExecute(r PipelinesApiUpdateRepositoryBuildNumberRequest) (*PipelineBuildNumber, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineBuildNumber
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryBuildNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/build_number"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdateRepositoryPipelineConfigRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	body *PipelinesConfig
}

// The updated repository pipelines configuration.
func (r PipelinesApiUpdateRepositoryPipelineConfigRequest) Body(body PipelinesConfig) PipelinesApiUpdateRepositoryPipelineConfigRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdateRepositoryPipelineConfigRequest) Execute() (*PipelinesConfig, *http.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineConfigExecute(r)
}

/*
UpdateRepositoryPipelineConfig Update configuration

Update the pipelines configuration for a repository.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiUpdateRepositoryPipelineConfigRequest
*/
func (a *PipelinesApiService) UpdateRepositoryPipelineConfig(ctx context.Context, workspace string, repoSlug string) PipelinesApiUpdateRepositoryPipelineConfigRequest {
	return PipelinesApiUpdateRepositoryPipelineConfigRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelinesConfig
func (a *PipelinesApiService) UpdateRepositoryPipelineConfigExecute(r PipelinesApiUpdateRepositoryPipelineConfigRequest) (*PipelinesConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelinesConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdateRepositoryPipelineKeyPairRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	body *PipelineSshKeyPair
}

// The created or updated SSH key pair.
func (r PipelinesApiUpdateRepositoryPipelineKeyPairRequest) Body(body PipelineSshKeyPair) PipelinesApiUpdateRepositoryPipelineKeyPairRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdateRepositoryPipelineKeyPairRequest) Execute() (*PipelineSshKeyPair, *http.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineKeyPairExecute(r)
}

/*
UpdateRepositoryPipelineKeyPair Update SSH key pair

Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @return PipelinesApiUpdateRepositoryPipelineKeyPairRequest
*/
func (a *PipelinesApiService) UpdateRepositoryPipelineKeyPair(ctx context.Context, workspace string, repoSlug string) PipelinesApiUpdateRepositoryPipelineKeyPairRequest {
	return PipelinesApiUpdateRepositoryPipelineKeyPairRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
	}
}

// Execute executes the request
//  @return PipelineSshKeyPair
func (a *PipelinesApiService) UpdateRepositoryPipelineKeyPairExecute(r PipelinesApiUpdateRepositoryPipelineKeyPairRequest) (*PipelineSshKeyPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineSshKeyPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineKeyPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdateRepositoryPipelineKnownHostRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	knownHostUuid string
	body *PipelineKnownHost
}

// The updated known host.
func (r PipelinesApiUpdateRepositoryPipelineKnownHostRequest) Body(body PipelineKnownHost) PipelinesApiUpdateRepositoryPipelineKnownHostRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdateRepositoryPipelineKnownHostRequest) Execute() (*PipelineKnownHost, *http.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineKnownHostExecute(r)
}

/*
UpdateRepositoryPipelineKnownHost Update a known host

Update a repository level known host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param knownHostUuid The UUID of the known host to update.
 @return PipelinesApiUpdateRepositoryPipelineKnownHostRequest
*/
func (a *PipelinesApiService) UpdateRepositoryPipelineKnownHost(ctx context.Context, workspace string, repoSlug string, knownHostUuid string) PipelinesApiUpdateRepositoryPipelineKnownHostRequest {
	return PipelinesApiUpdateRepositoryPipelineKnownHostRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		knownHostUuid: knownHostUuid,
	}
}

// Execute executes the request
//  @return PipelineKnownHost
func (a *PipelinesApiService) UpdateRepositoryPipelineKnownHostExecute(r PipelinesApiUpdateRepositoryPipelineKnownHostRequest) (*PipelineKnownHost, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineKnownHost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineKnownHost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"known_host_uuid"+"}", url.PathEscape(parameterToString(r.knownHostUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdateRepositoryPipelineScheduleRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	scheduleUuid string
	body *PipelineSchedule
}

// The schedule to update.
func (r PipelinesApiUpdateRepositoryPipelineScheduleRequest) Body(body PipelineSchedule) PipelinesApiUpdateRepositoryPipelineScheduleRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdateRepositoryPipelineScheduleRequest) Execute() (*PipelineSchedule, *http.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineScheduleExecute(r)
}

/*
UpdateRepositoryPipelineSchedule Update a schedule

Update a schedule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param scheduleUuid The uuid of the schedule.
 @return PipelinesApiUpdateRepositoryPipelineScheduleRequest
*/
func (a *PipelinesApiService) UpdateRepositoryPipelineSchedule(ctx context.Context, workspace string, repoSlug string, scheduleUuid string) PipelinesApiUpdateRepositoryPipelineScheduleRequest {
	return PipelinesApiUpdateRepositoryPipelineScheduleRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		scheduleUuid: scheduleUuid,
	}
}

// Execute executes the request
//  @return PipelineSchedule
func (a *PipelinesApiService) UpdateRepositoryPipelineScheduleExecute(r PipelinesApiUpdateRepositoryPipelineScheduleRequest) (*PipelineSchedule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineSchedule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"schedule_uuid"+"}", url.PathEscape(parameterToString(r.scheduleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PipelinesApiUpdateRepositoryPipelineVariableRequest struct {
	ctx context.Context
	ApiService *PipelinesApiService
	workspace string
	repoSlug string
	variableUuid string
	body *PipelineVariable
}

// The updated variable
func (r PipelinesApiUpdateRepositoryPipelineVariableRequest) Body(body PipelineVariable) PipelinesApiUpdateRepositoryPipelineVariableRequest {
	r.body = &body
	return r
}

func (r PipelinesApiUpdateRepositoryPipelineVariableRequest) Execute() (*PipelineVariable, *http.Response, error) {
	return r.ApiService.UpdateRepositoryPipelineVariableExecute(r)
}

/*
UpdateRepositoryPipelineVariable Update a variable for a repository

Update a repository level variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workspace This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example `{workspace UUID}`.
 @param repoSlug The repository.
 @param variableUuid The UUID of the variable to update.
 @return PipelinesApiUpdateRepositoryPipelineVariableRequest
*/
func (a *PipelinesApiService) UpdateRepositoryPipelineVariable(ctx context.Context, workspace string, repoSlug string, variableUuid string) PipelinesApiUpdateRepositoryPipelineVariableRequest {
	return PipelinesApiUpdateRepositoryPipelineVariableRequest{
		ApiService: a,
		ctx: ctx,
		workspace: workspace,
		repoSlug: repoSlug,
		variableUuid: variableUuid,
	}
}

// Execute executes the request
//  @return PipelineVariable
func (a *PipelinesApiService) UpdateRepositoryPipelineVariableExecute(r PipelinesApiUpdateRepositoryPipelineVariableRequest) (*PipelineVariable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PipelineVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PipelinesApiService.UpdateRepositoryPipelineVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"workspace"+"}", url.PathEscape(parameterToString(r.workspace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repo_slug"+"}", url.PathEscape(parameterToString(r.repoSlug, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variable_uuid"+"}", url.PathEscape(parameterToString(r.variableUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
